{"ast":null,"code":"/** pact-lang-api.js\n * Exports functions to support Pact API calls.\n * Author: Will Martino, Hee Kyun Yun, Stuart Popejoy\n * Supports: Pact API 3.0 v1\n */\nconst blake = require(\"blakejs\");\n\nconst nacl = require(\"tweetnacl\");\n\nconst base64url = require(\"base64-url\");\n\nconst fetch = require(\"node-fetch\");\n/**\n * Convert binary to hex.\n * @param s {Uint8Array} - binary value\n * @return {string} hex string\n */\n\n\nvar binToHex = function (s) {\n  var constructor = s.constructor.name || null;\n\n  if (constructor !== \"Uint8Array\") {\n    throw new TypeError(\"Expected Uint8Array\");\n  }\n\n  return Buffer.from(s).toString(\"hex\");\n};\n/**\n * Convert hex string to binary.\n * @param s {string} - hex string\n * @return {Uint8Array} binary value\n */\n\n\nvar hexToBin = function (h) {\n  if (typeof h !== \"string\") {\n    throw new TypeError(\"Expected string: \" + h);\n  }\n\n  return new Uint8Array(Buffer.from(h, \"hex\"));\n};\n/**\n * Perform blake2b256 hashing.\n */\n\n\nvar hashBin = function (s) {\n  return blake.blake2b(s, null, 32);\n};\n/**\n * Perform blake2b256 hashing, encoded as unescaped base64url.\n */\n\n\nvar hash = function (s) {\n  return base64UrlEncode(hashBin(s));\n};\n/**\n * Hash string as unescaped base64url.\n */\n\n\nvar base64UrlEncode = function (s) {\n  return base64url.escape(base64url.encode(s));\n};\n/**\n * Generate a random ED25519 keypair.\n * @return {object} with \"publicKey\" and \"secretKey\" fields.\n */\n\n\nvar genKeyPair = function () {\n  var kp = nacl.sign.keyPair();\n  var pubKey = binToHex(kp.publicKey);\n  var secKey = binToHex(kp.secretKey).slice(0, 64);\n  return {\n    publicKey: pubKey,\n    secretKey: secKey\n  };\n};\n\nvar toTweetNaclSecretKey = function (keyPair) {\n  if (!keyPair.hasOwnProperty(\"publicKey\") || !keyPair.hasOwnProperty(\"secretKey\")) {\n    throw new TypeError(\"Invalid KeyPair: expected to find keys of name 'secretKey' and 'publicKey': \" + JSON.stringify(keyPair));\n  }\n\n  return hexToBin(keyPair.secretKey + keyPair.publicKey);\n};\n/**\n * Sign data using key pair.\n * @param msg - some data to be passed to blake2b256.\n * @param keyPair - signing ED25519 keypair\n * @return {object} with \"hash\", \"sig\" (signature in hex format), and \"pubKey\" public key value.\n */\n\n\nvar sign = function (msg, keyPair) {\n  if (!keyPair.hasOwnProperty(\"publicKey\") || !keyPair.hasOwnProperty(\"secretKey\")) {\n    throw new TypeError(\"Invalid KeyPair: expected to find keys of name 'secretKey' and 'publicKey': \" + JSON.stringify(keyPair));\n  }\n\n  var hshBin = hashBin(msg);\n  var hsh = base64UrlEncode(hshBin);\n  var sigBin = nacl.sign.detached(hshBin, toTweetNaclSecretKey(keyPair));\n  return {\n    hash: hsh,\n    sig: binToHex(sigBin),\n    pubKey: keyPair.publicKey\n  };\n};\n\nvar pullSig = function (s) {\n  if (!s.hasOwnProperty(\"sig\")) {\n    throw new TypeError(\"Expected to find keys of name 'sig' in \" + JSON.stringify(s));\n  }\n\n  return {\n    sig: s.sig\n  };\n};\n\nvar pullAndCheckHashs = function (sigs) {\n  var hsh = sigs[0].hash;\n\n  for (var i = 1; i < sigs.length; i++) {\n    if (sigs[i].hash !== hsh) {\n      throw new Error(\"Sigs for different hashes found: \" + JSON.stringify(sigs));\n    }\n  }\n\n  return hsh;\n};\n/**\n * Prepare an ExecMsg pact command for use in send or local execution.\n * To use in send, wrap result with 'mkSingleCommand'.\n * @param keyPairs {array or object} - array or single ED25519 keypair and/or clist (list of `cap` in mkCap)\n * @param nonce {string} - nonce value for ensuring unique hash\n * @param pactCode {string} - pact code to execute\n * @param envData {object} - JSON message data for command\n * @param meta {object} - public meta information, see mkMeta\n * @return valid pact API command for send or local use.\n */\n\n\nvar prepareExecCmd = function (keyPairs, nonce = new Date().toISOString(), pactCode, envData, meta = mkMeta(\"\", \"\", 0, 0, 0, 0), networkId = null) {\n  enforceType(nonce, \"string\", \"nonce\");\n  enforceType(pactCode, \"string\", \"pactCode\");\n  var kpArray = asArray(keyPairs);\n  var signers = kpArray.map(mkSigner);\n  var cmdJSON = {\n    networkId: networkId,\n    payload: {\n      exec: {\n        data: envData || {},\n        code: pactCode\n      }\n    },\n    signers: signers,\n    meta: meta,\n    nonce: JSON.stringify(nonce)\n  };\n  var cmd = JSON.stringify(cmdJSON);\n  var sigs = kpArray.map(function (kp) {\n    return sign(cmd, kp);\n  });\n  return mkSingleCmd(sigs, cmd);\n};\n/**\n * Makes a single command given signed data.\n * @param sigs {array} - array of signature objects, see 'sign'\n * @param cmd {string} - stringified JSON blob used to create hash\n * @return valid Pact API command for send or local use.\n */\n\n\nvar mkSingleCmd = function (sigs, cmd) {\n  enforceArray(sigs, \"sigs\");\n  enforceType(cmd, \"string\", \"cmd\");\n  return {\n    hash: pullAndCheckHashs(sigs),\n    sigs: sigs.map(pullSig),\n    cmd: cmd\n  };\n};\n/**\n * Makes outer wrapper for a 'send' endpoint.\n * @param {array or object} cmds - one or an array of commands, see mkSingleCmd\n */\n\n\nvar mkPublicSend = function (cmds) {\n  return {\n    cmds: asArray(cmds)\n  };\n};\n/**\n * Make an ED25519 \"signer\" array element for inclusion in a Pact payload.\n * @param {object} kp - a ED25519 keypair and/or clist (list of `cap` in mkCap)\n * @return {object} an object with pubKey, addr and scheme fields.\n */\n\n\nvar mkSigner = function (kp) {\n  return {\n    clist: kp.clist ? asArray(kp.clist) : [],\n    pubKey: kp.publicKey\n  };\n};\n\nvar asArray = function (singleOrArray) {\n  if (Array.isArray(singleOrArray)) {\n    return singleOrArray;\n  } else {\n    return [singleOrArray];\n  }\n};\n\nvar enforceType = function (val, type, msg) {\n  if (typeof val !== type) {\n    throw new TypeError(msg + \" must be a \" + type + \": \" + JSON.stringify(val));\n  }\n};\n\nvar enforceArray = function (val, msg) {\n  if (!Array.isArray(val)) {\n    throw new TypeError(msg + \" must be an array: \" + JSON.stringify(val));\n  }\n};\n/**\n * Make a full 'send' endpoint exec command. See 'prepareExecCmd' for parameters.\n */\n\n\nvar simpleExecCommand = function (keyPairs, nonce, pactCode, envData, meta) {\n  return mkPublicSend(prepareExecCmd(keyPairs, nonce, pactCode, envData, meta));\n};\n\nvar unique = function (arr) {\n  var n = {},\n      r = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (!n[arr[i]]) {\n      n[arr[i]] = true;\n      r.push(arr[i]);\n    }\n  }\n\n  return r;\n};\n/**\n * Given an exec 'send' message, prepare a message for 'poll' endpoint.\n * @param execMsg {object} JSON with \"cmds\" field, see 'mkPublicSend'\n * @return {object} with \"requestKeys\" for polling.\n */\n\n\nvar simplePollRequestFromExec = function (execMsg) {\n  var cmds = execMsg.cmds || TypeError(\"expected key 'cmds' in object: \" + JSON.stringify(execMsg));\n  var rks = [];\n\n  if (!cmds.every(function (v) {\n    return v.hasOwnProperty(\"hash\");\n  })) {\n    throw new TypeError('maleformed object, expected \"hash\" key in every cmd: ' + JSON.stringify(execMsg));\n  } else {\n    rks = unique(cmds.map(function (v) {\n      return v.hash;\n    }));\n  }\n\n  return {\n    requestKeys: rks\n  };\n};\n/**\n * Given an exec 'send' message, prepare a message for 'listen' endpoint.\n * @param execMsg {object} JSON with \"cmds\" field, see 'mkPublicSend'. Only takes first element.\n * @return {object} with \"requestKey\" for polling.\n */\n\n\nvar simpleListenRequestFromExec = function (execMsg) {\n  var cmds = execMsg.cmds || TypeError(\"expected key 'cmds' in object: \" + JSON.stringify(execMsg));\n  var rks = [];\n\n  if (!cmds.every(function (v) {\n    return v.hasOwnProperty(\"hash\");\n  })) {\n    throw new TypeError('maleformed object, expected \"hash\" key in every cmd: ' + JSON.stringify(execMsg));\n  } else {\n    rks = unique(cmds.map(function (v) {\n      return v.hash;\n    }));\n  }\n\n  return {\n    listen: rks[0]\n  };\n};\n/**\n * Variadic function to form a lisp s-expression application.\n * Encases arguments in parens and intercalates with a space.\n */\n\n\nvar mkExp = function (pgmName) {\n  enforceType(pgmName, \"string\", \"pgmName\");\n  return \"(\" + pgmName + \" \" + Array.prototype.slice.call(arguments, 1).map(JSON.stringify).join(\" \") + \")\";\n};\n/**\n * Prepare a chainweb-style public meta payload.\n * @param sender {string} gas account\n * @param chainId {string} chain identifier\n * @param gasPrice {number} desired gas price\n * @param gasLimit {number} desired gas limit\n * @param creationTime {number} desired tx's time created in UNIX epoch time as seconds\n * @param ttl {number} desired tx's time to live as seconds\n * @return {object} of arguments, type-checked and properly named.\n */\n\n\nvar mkMeta = function (sender, chainId, gasPrice, gasLimit, creationTime, ttl) {\n  enforceType(sender, \"string\", \"sender\");\n  enforceType(chainId, \"string\", \"chainId\");\n  enforceType(gasPrice, \"number\", \"gasPrice\");\n  enforceType(gasLimit, \"number\", \"gasLimit\");\n  enforceType(creationTime, \"number\", \"creationTime\");\n  enforceType(ttl, \"number\", \"ttl\");\n  return {\n    creationTime: creationTime,\n    ttl: ttl,\n    gasLimit: gasLimit,\n    chainId: chainId,\n    gasPrice: gasPrice,\n    sender: sender\n  };\n};\n/**\n * Formats ExecCmd into api request object\n */\n\n\nvar mkReq = function (cmd) {\n  return {\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    method: \"POST\",\n    body: JSON.stringify(cmd)\n  };\n};\n/**\n * A Command Object to Execute in Pact Server.\n * @typedef {Object} execCmd\n * @property pactCode {string} pact code to execute\n * @property keyPairs {array or object} array or single ED25519 keypair and/or clist (list of `cap` in mkCap)\n * @property nonce {string} nonce value, default at current time\n * @property envData {object} JSON message data for command, default at empty obj\n * @property meta {object} meta information, see mkMeta\n * @property networkId {object} network identifier of where the cmd is executed.\n */\n\n/**\n * Sends Pact command to a running Pact server and retrieves tx result.\n * @param {[execCmd] or execCmd} sendCmd cmd or a list of cmd's to execute\n * @param {string} apiHost host running Pact server\n * @return {object} Request key of the tx received from pact server.\n */\n\n\nconst fetchSend = async function (sendCmd, apiHost) {\n  if (!apiHost) throw new Error(\"Pact.fetch.send(): No apiHost provided\");\n  const sendCmds = asArray(sendCmd).map(cmd => prepareExecCmd(cmd.keyPairs, cmd.nonce, cmd.pactCode, cmd.envData, cmd.meta, cmd.networkId));\n  const txRes = await fetch(\"\".concat(apiHost, \"/api/v1/send\"), mkReq(mkPublicSend(sendCmds)));\n  const tx = await txRes.json();\n  return tx;\n};\n/**\n * Sends Local Pact command to a local Pact server and retrieves local tx result.\n * @param {execCmd} localCmd a single cmd to execute locally\n * @param {string} apiHost host running Pact server\n * @return {object} tx result received from pact server.\n */\n\n\nconst fetchLocal = async function (localCmd, apiHost) {\n  if (!apiHost) throw new Error(\"Pact.fetch.local(): No apiHost provided\");\n  const keyPairs = localCmd.keyPairs,\n        nonce = localCmd.nonce,\n        pactCode = localCmd.pactCode,\n        envData = localCmd.envData,\n        meta = localCmd.meta,\n        networkId = localCmd.networkId;\n  const cmd = prepareExecCmd(keyPairs, nonce, pactCode, envData, meta, networkId);\n  const txRes = await fetch(\"\".concat(apiHost, \"/api/v1/local\"), mkReq(cmd));\n  const tx = await txRes.json();\n  return tx.result;\n};\n/**\n * Request poll Pact command to a running Pact server and retrieves tx result.\n * @param {{requestKeys: [<rk:string>]}} pollCmd request Keys of txs to poll.\n * @param {string} apiHost host running Pact server\n * @return {object} Array of tx request keys and tx results from pact server.\n */\n\n\nconst fetchPoll = async function (pollCmd, apiHost) {\n  if (!apiHost) throw new Error(\"Pact.fetch.poll(): No apiHost provided\");\n  const res = await fetch(\"\".concat(apiHost, \"/api/v1/poll\"), mkReq(pollCmd));\n  const resJSON = await res.json();\n  return Object.values(resJSON).map(res => {\n    return {\n      reqKey: res.reqKey,\n      result: res.result\n    };\n  });\n};\n/**\n * Request listen Pact command to a running Pact server and retrieves tx result.\n * @param {{listenCmd: <rk:string>}} listenCmd reqest key of tx to listen.\n * @param {string} apiHost host running Pact server\n * @return {object} Object containing tx result from pact server\n */\n\n\nconst fetchListen = async function (listenCmd, apiHost) {\n  if (!apiHost) throw new Error(\"Pact.fetch.listen(): No apiHost provided\");\n  const res = await fetch(\"\".concat(apiHost, \"/api/v1/listen\"), mkReq(listenCmd));\n  const resJSON = await res.json();\n  return resJSON.result;\n};\n/**\n  Signing API functions to interact with Chainweaver wallet (https://github.com/kadena-io/chainweaver) and its signing API.\n */\n\n/**\n * Prepares a capability object to be signed with keyPairs using signing API.\n * @param role {string} role of the pact capability\n * @param description {string} description of the pact capability\n * @param name {string} name of pact capability to be signed\n * @param args {array} array of arguments used in pact capability, default to empty array.\n * @return {object} A properly formatted cap object required in signingCmd\n */\n\n\nvar mkCap = function (role, description, name, args = []) {\n  enforceType(role, \"string\", \"role\");\n  enforceType(description, \"string\", \"description\");\n  enforceType(name, \"string\", \"name of capability\");\n  enforceType(args, \"object\", \"arguments to capability\");\n  return {\n    role: role,\n    description: description,\n    cap: {\n      name: name,\n      args: args\n    }\n  };\n};\n/**\n * A signingCmd Object to be sent to signing API\n * @typedef {Object} signingCmd - cmd to be sent to signing API\n * @property pactCode {string} - Pact code to execute - required\n * @property caps {array or object} - Pact capability to be signed, see mkCap - required\n * @property envData {object} - JSON message data for command - optional\n * @property sender {string} - sender field in meta, see mkMeta - optional\n * @property chainId {string} - chainId field in meta, see mkMeta - optional\n * @property gasLimit {number} - gasLimit field in meta, see mkMeta - optional\n * @property nonce {string} - nonce value for ensuring unique hash - optional\n **/\n\n/**\n * Sends parameters of Pact Command to the Chainweaver signing API and retrieves a signed Pact Command.\n * @param signingCmd - cmd to be sent to signing API\n * @return {object} valid pact ExecCmd for send or local use.\n **/\n\n\nconst signWallet = async function (signingCmd) {\n  if (!signingCmd.pactCode) throw new Error(\"Pact.wallet.sign(): No Pact Code provided\");\n  if (!signingCmd.caps) throw new Error(\"Pact.wallet.sign(): No Caps provided\");\n  enforceType(signingCmd.pactCode, \"string\", \"pactCode\");\n  enforceType(signingCmd.caps, \"object\", \"caps\");\n  if (signingCmd.envData) enforceType(signingCmd.envData, \"object\", \"envData\");\n  if (signingCmd.sender) enforceType(signingCmd.sender, \"string\", \"sender\");\n  if (signingCmd.chainId) enforceType(signingCmd.chainId, \"string\", \"chainId\");\n  if (signingCmd.gasLimit) enforceType(signingCmd.gasLimit, \"number\", \"gasLimit\");\n  if (signingCmd.nonce) enforceType(signingCmd.nonce, \"string\", \"nonce\");\n  if (signingCmd.ttl) enforceType(signingCmd.ttl, \"number\", \"ttl\");\n  const cmd = {\n    code: signingCmd.pactCode,\n    caps: asArray(signingCmd.caps),\n    data: signingCmd.envData,\n    sender: signingCmd.sender,\n    chainId: signingCmd.chainId,\n    gasLimit: signingCmd.gasLimit,\n    nonce: signingCmd.nonce,\n    ttl: signingCmd.ttl\n  };\n  const res = await fetch('http://127.0.0.1:9467/v1/sign', mkReq(cmd));\n  const resJSON = await res.json();\n  return resJSON.body;\n};\n/**\n * Sends a signed Pact ExecCmd to a running Pact server and retrieves tx result.\n * @param {signedCmd} valid pact API command for send or local use.\n * @param {string} apiHost host running Pact server\n * @return {object} Request key of the tx received from pact server.\n */\n\n\nconst sendSigned = async function (signedCmd, apiHost) {\n  const cmd = {\n    \"cmds\": [signedCmd]\n  };\n  const txRes = await fetch(\"\".concat(apiHost, \"/api/v1/send\"), mkReq(cmd));\n  const tx = await txRes.json();\n  return tx;\n};\n\nmodule.exports = {\n  crypto: {\n    binToHex: binToHex,\n    hexToBin: hexToBin,\n    base64UrlEncode: base64UrlEncode,\n    hash: hash,\n    genKeyPair: genKeyPair,\n    sign: sign,\n    toTweetNaclSecretKey: toTweetNaclSecretKey\n  },\n  api: {\n    prepareExecCmd: prepareExecCmd,\n    mkSingleCmd: mkSingleCmd,\n    mkPublicSend: mkPublicSend\n  },\n  lang: {\n    mkExp: mkExp,\n    mkMeta: mkMeta,\n    mkCap: mkCap\n  },\n  simple: {\n    exec: {\n      createCommand: simpleExecCommand,\n      createLocalCommand: prepareExecCmd,\n      createPollRequest: simplePollRequestFromExec,\n      createListenRequest: simpleListenRequestFromExec\n    }\n  },\n  fetch: {\n    send: fetchSend,\n    local: fetchLocal,\n    poll: fetchPoll,\n    listen: fetchListen\n  },\n  wallet: {\n    sign: signWallet,\n    sendSigned: sendSigned\n  }\n};","map":null,"metadata":{},"sourceType":"script"}